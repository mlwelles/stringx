// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/noho-digital/genny

package stringx

import "github.com/noho-digital/mapset"

// reset these in an init in the dest package if you dont want the defaults
var __StringSetReceiverAutoConvertComparisonStringSetsToMatchingThreadSafeUnsafeVariants = true

//
//type Iterator struct {
//	*mapset.Iterator
//}

type ReadOnlyStringSet interface {

	// Note that the argument to all methods that
	// take a ReadOnlyStringSet or StringSet as arguments
	// must pass a set that is of the same thread safe / unsafe variant
	// as the receiver of the method or one of two things will happen:
	//
	//      - the receiever will create a copy of the comparison set that is of the same thread
	//        safe / unsafe type variant as itself, and use it in the operation.
	//
	//   OR
	//       - it will panic.
	// This behavior is controlled by the value of:
	//
	// __StringSetReceiverAutoConvertComparisonStringSetsToMatchingThreadSafeUnsafeVariants
	//
	// The default is true, which means expensive copies will be performed
	//
	// This can be be overridden at run in an init() function
	// in the package that StringSet is generated into.

	// Synonym for Cardinality() for folks more familar with go than set theory
	Len() int

	// Returns the number of elements in the set.
	Cardinality() int

	// Returns a clone of the set using the same
	// implementation, duplicating all keys.
	Clone() StringSet

	// Returns whether the given items
	// are all in the set.
	Contains(i ...string) bool

	// Returns if the given item is not in the set
	NotContains(i string) bool

	// Returns whether any the given items
	// are not in the set
	NotContainsAny(i ...string) bool

	// Returns whether any any given items
	// in the set.
	ContainsAny(i ...string) bool

	// Returns whether any given items
	// are all in the set.
	ContainsAll(i ...string) bool

	// Returns the difference between this set
	// and other. The returned set will contain
	// all elements of this set that are not also
	// elements of other.
	Difference(other ReadOnlyStringSet) StringSet

	// Determines if two sets are equal to each
	// other. If they have the same cardinality
	// and contain the same elements, they are
	// considered equal. The order in which
	// the elements were added is irrelevant.
	//
	Equal(other ReadOnlyStringSet) bool

	//
	// !set.Equal(other)
	//
	NotEqual(other ReadOnlyStringSet) bool

	// Returns true if there are
	// any elements that exist in both sets
	Intersects(other ReadOnlyStringSet) bool

	// Returns a new set containing only the elements
	// that exist only in both sets.
	Intersect(other ReadOnlyStringSet) StringSet

	// Returns true if there is no
	// elements that exist both in the
	// receiver set and the argument
	IsDisjoint(other ReadOnlyStringSet) bool

	// Determines if every element in this set is in
	// the other set but the two sets are not equal.
	IsProperSubset(other ReadOnlyStringSet) bool

	// Determines if every element in the other set
	// is in this set but the two sets are not
	// equal.
	IsProperSuperset(other ReadOnlyStringSet) bool

	// Determines if every element in this set is in
	// the other set.
	IsSubset(other ReadOnlyStringSet) bool

	// Determines if every element in the other set
	// is in this set.
	IsSuperset(other ReadOnlyStringSet) bool

	// Iterates over elements and executes the passed func against each element.
	// If passed func returns true, stop iteration at the time.
	Each(func(string) bool)

	String() string

	// Returns a new set with all elements in both sets.
	Union(other ReadOnlyStringSet) StringSet

	// Returns the Cartesian Product of two sets.
	CartesianProduct(other ReadOnlyStringSet) StringSet
	// Returns the members of the set as a slice.
	ToSlice() []string

	// Returns true if the receiver is not empty and it contains the argument item
	NotEmptyAndContains(item string) bool

	// Returns true if the receiver is not empty and does not contain argument item
	NotEmptyAndNotContains(item string) bool

	// Returns true if the receiver is empty (i.e. if Cardinality() == 0)
	Empty() bool
	// Returns true if the receiver id not empty (i.e. if Cardinality() > 0)
	NotEmpty() bool

	// Returns true if the receiver is nil
	Nil() bool

	// Returns true if the receiver is not nil
	NotNil() bool

	// Returns a new set with all elements which are
	// in either this set or the other set but not in both.
	SymmetricDifference(other ReadOnlyStringSet) StringSet

	// Returns all subsets of a given set (Power Set).
	PowerSet() StringSet

	// Returns true if reciver is thread safe type variant,
	// wil be true if created with the NewStringSet() and NewStringSetFromSlice()
	// constructs, will be false if it was created with the
	// NewThreadUnsafeStringSet(0 and NewThreadUnsafeStringSetFromSlice() constructors
	IsThreadSafe() bool

	// Returns the backing untyped mapset.Set interface{} set reciever wraps
	MapsetSet() mapset.Set
}

type StringSet interface {
	ReadOnlyStringSet

	// Adds an element to the set. Returns whether
	// the item was added.
	Add(i string) bool

	// Adds all the items specified as arguments to the set
	// Returns an array of booleans indicating which of the items
	// was added.
	AddAll(items ...string) []bool

	// Removes all elements from the set, leaving
	// the empty set.
	Clear()

	// Remove a single element from the set.
	Remove(i string)

	// Pop removes and returns an arbitrary item from the set.
	Pop() string
}

type mapsetStringSet struct {
	ms           mapset.Set
	isThreadSafe bool
}

func (s *mapsetStringSet) NotContains(i string) bool {
	if s == nil {
		return false
	}
	return !s.Contains(i)
}

func (s *mapsetStringSet) NotContainsAny(tt ...string) bool {
	for _, t := range tt {
		if !s.Contains(t) {
			return true
		}
	}
	return false
}

func (s *mapsetStringSet) Nil() bool {
	return s == nil
}

func (s *mapsetStringSet) NotNil() bool {
	return s != nil
}

func (s *mapsetStringSet) IsDisjoint(other ReadOnlyStringSet) bool {
	switch {
	case s == nil || other == nil:
		return false
	case s.IsThreadSafe() != other.IsThreadSafe():
		return !s.Intersects(other)
	default:
		return s.MapsetSet().Intersect(other.MapsetSet()).Cardinality() == 0
	}
}

func (s *mapsetStringSet) Intersects(o ReadOnlyStringSet) bool {
	if o == nil || s == nil {
		return false
	}
	return s.ContainsAny(o.ToSlice()...)
}

func (s *mapsetStringSet) ContainsAny(items ...string) bool {
	if s == nil {
		return false
	}
	for _, i := range items {
		if s.ms.Contains(i) {
			return true
		}
	}
	return false
}

func (s *mapsetStringSet) ContainsAll(i ...string) bool {
	return s.Contains(i...)
}

func (s *mapsetStringSet) MapsetSet() mapset.Set {
	if s == nil {
		return nil
	}
	return s.ms
}

func (s *mapsetStringSet) Add(i string) bool {
	return s.ms.Add(i)
}

func (s *mapsetStringSet) AddAll(il ...string) []bool {
	var rl []bool
	for _, i := range il {
		rl = append(rl, s.ms.Add(i))
	}
	return rl
}

func (s *mapsetStringSet) Len() int {
	return s.ms.Cardinality()
}

func (s *mapsetStringSet) Cardinality() int {
	return s.ms.Cardinality()
}

func (s *mapsetStringSet) Clear() {
	s.ms.Clear()
}

func (s *mapsetStringSet) Clone() StringSet {
	if s == nil {
		return nil
	}
	return &mapsetStringSet{ms: s.ms.Clone(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetStringSet) Contains(t ...string) bool {
	if s == nil {
		return false
	}
	i := __convertStringSliceToInterfaceSlice(t)
	return s.ms.Contains(i...)
}

func (s *mapsetStringSet) Difference(other ReadOnlyStringSet) StringSet {
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	return &mapsetStringSet{ms: s.ms.Difference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetStringSet) Equal(other ReadOnlyStringSet) bool {
	if s == nil {
		return s == other
	}
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	return s.ms.Equal(other.MapsetSet())
}

func (s *mapsetStringSet) NotEqual(other ReadOnlyStringSet) bool {
	return !s.ms.Equal(other.MapsetSet())
}

func (s *mapsetStringSet) Intersect(other ReadOnlyStringSet) StringSet {
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	ms := s.MapsetSet().Intersect(other.MapsetSet())
	return &mapsetStringSet{ms: ms, isThreadSafe: s.isThreadSafe}
}

func (s *mapsetStringSet) IsProperSubset(other ReadOnlyStringSet) bool {
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSubset(other.MapsetSet())
}

func (s *mapsetStringSet) IsProperSuperset(other ReadOnlyStringSet) bool {
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsProperSuperset(other.MapsetSet())
}

func (s *mapsetStringSet) IsSubset(other ReadOnlyStringSet) bool {
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSubset(other.MapsetSet())
}

func (s *mapsetStringSet) IsSuperset(other ReadOnlyStringSet) bool {
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	return s.ms.IsSuperset(other.MapsetSet())
}

func (s *mapsetStringSet) Each(f func(string) bool) {
	fi := func(i interface{}) bool {
		t, ok := i.(string)
		if !ok {
			return false
		}
		return f(t)

	}
	s.ms.Each(fi)
}

func (s *mapsetStringSet) IsThreadSafe() bool {
	return s.isThreadSafe
}

func (s *mapsetStringSet) Remove(i string) {
	s.ms.Remove(i)
}

func (s *mapsetStringSet) String() string {
	return s.ms.String()
}

func (s *mapsetStringSet) SymmetricDifference(other ReadOnlyStringSet) StringSet {
	return &mapsetStringSet{ms: s.ms.SymmetricDifference(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetStringSet) Union(other ReadOnlyStringSet) StringSet {
	switch {
	case s != nil && other != nil:
		other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
		return &mapsetStringSet{ms: s.ms.Union(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
	case s == nil:
		if other == nil {
			return nil
		}
		return other.Union(__emptyStringSetMatchingString(other))
	default:
		return s.Union(__emptyStringSetMatchingString(s))
	}
}

func (s *mapsetStringSet) Pop() string {
	var def string
	i := s.ms.Pop()
	if i == nil {
		return def
	}
	return __convertInterfaceToString(i)
}

func (s *mapsetStringSet) PowerSet() StringSet {
	return &mapsetStringSet{ms: s.ms.PowerSet(), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetStringSet) CartesianProduct(other ReadOnlyStringSet) StringSet {
	other = __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other)
	return &mapsetStringSet{ms: s.ms.CartesianProduct(other.MapsetSet()), isThreadSafe: s.isThreadSafe}
}

func (s *mapsetStringSet) ToSlice() []string {
	if s == nil {
		return nil
	}
	return ___convertInterfaceSliceToStringSlice(s.ms.ToSlice())
}

func (s *mapsetStringSet) NotEmptyAndContains(item string) bool {
	return (!s.Empty()) && s.Contains(item)
}

func (s *mapsetStringSet) NotEmptyAndNotContains(item string) bool {
	return (!s.Empty()) && (!s.Contains(item))
}

func (s *mapsetStringSet) NotEmpty() bool {
	return s.Cardinality() > 0
}

func (s *mapsetStringSet) Empty() bool {
	return s.Cardinality() == 0
}

func (s *mapsetStringSet) AddItems(items ...string) int {
	n := 0
	for _, i := range items {
		if s.Add(i) {
			n++
		}
	}
	return n
}

// NewInterfaceSet creates and returns a reference to an empty set.  Operations
// on the resulting set are thread-safe.
func NewStringSet(items ...string) StringSet {
	return newMapsetStringSet(items...)
}

func newMapsetStringSet(items ...string) *mapsetStringSet {
	ms := mapset.NewSet()
	for _, t := range items {
		ms.Add(t)
	}
	return &mapsetStringSet{ms: ms, isThreadSafe: true}
}

// NewStringSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// thread-safe.
func NewStringSetFromSlice(s []string) StringSet {
	i := __convertStringSliceToInterfaceSlice(s)
	return &mapsetStringSet{ms: mapset.NewSetFromSlice(i), isThreadSafe: true}
}

// NewThreadUnsafeStringSet creates and returns a reference to either an empty set from a slice composed of the
// optional arguments.
func NewThreadUnsafeStringSet(i ...string) StringSet {
	ms := mapset.NewThreadUnsafeSet()
	for _, t := range i {
		ms.Add(t)
	}
	return &mapsetStringSet{ms: ms, isThreadSafe: false}
}

// NewThreadUnsafeSetFromSlice creates and returns a reference to a
// set from an existing slice.  Operations on the resulting set are
// not thread-safe.
func NewThreadUnsafeStringSetFromSlice(s []string) StringSet {
	i := __convertStringSliceToInterfaceSlice(s)
	return &mapsetStringSet{ms: mapset.NewThreadUnsafeSetFromSlice(i), isThreadSafe: false}
}

func __ensureThreadSafeStringSet(other ReadOnlyStringSet) ReadOnlyStringSet {
	if other.IsThreadSafe() {
		return other
	}
	return NewStringSetFromSlice(other.ToSlice())
}

func __ensureThreadUnsafeStringSet(other ReadOnlyStringSet) ReadOnlyStringSet {
	if other.IsThreadSafe() {
		return NewThreadUnsafeStringSetFromSlice(other.ToSlice())
	}
	return other
}
func __autoConvertToThreadSafeUnsafeStringSetMatchingCopyIfEnabled(s, other ReadOnlyStringSet) ReadOnlyStringSet {
	if !__StringSetReceiverAutoConvertComparisonStringSetsToMatchingThreadSafeUnsafeVariants {
		return other
	}
	if s.IsThreadSafe() {
		return __ensureThreadSafeStringSet(other)
	}

	return __ensureThreadUnsafeStringSet(other)
}

func __convertStringSliceToInterfaceSlice(typeSlice []string) []interface{} {
	interfaceSlice := make([]interface{}, len(typeSlice))
	for i := range typeSlice {
		interfaceSlice[i] = typeSlice[i]
	}
	return interfaceSlice
}

func __convertInterfaceToString(item interface{}) string {
	t, ok := item.(string)
	if !ok {
		panic("item is not correct type")
	}
	return t
}

func ___convertInterfaceSliceToStringSlice(interfaceSlice []interface{}) []string {
	typeSlice := make([]string, len(interfaceSlice))
	for i, item := range interfaceSlice {
		typeSlice[i] = __convertInterfaceToString(item)
	}
	return typeSlice
}

func __emptyStringSetMatchingString(s ReadOnlyStringSet) ReadOnlyStringSet {
	if s.IsThreadSafe() {
		return __emptyStringSet
	} else {
		return __emptyThreadUnsafeStringSet
	}
}

var __emptyStringSet = NewStringSet()
var __emptyThreadUnsafeStringSet = NewThreadUnsafeStringSet()
